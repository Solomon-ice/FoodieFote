// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview Identifies food items in an image.
 *
 * - identifyFood - A function that handles the food identification process.
 * - IdentifyFoodInput - The input type for the identifyFood function.
 * - IdentifyFoodOutput - The return type for the identifyFood function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const IdentifyFoodInputSchema = z.object({
  photoDataUri: z
    .string()
    .describe(
      "A photo of food, as a data URI that must include a MIME type and use Base64 encoding. Expected format: 'data:<mimetype>;base64,<encoded_data>'."
    ),
});
export type IdentifyFoodInput = z.infer<typeof IdentifyFoodInputSchema>;

const IdentifyFoodOutputSchema = z.object({
  foodItems: z.array(z.string()).describe('An array of food items identified in the image.'),
  isFood: z.boolean().describe('Whether or not the image contains food.'),
});
export type IdentifyFoodOutput = z.infer<typeof IdentifyFoodOutputSchema>;

export async function identifyFood(input: IdentifyFoodInput): Promise<IdentifyFoodOutput> {
  return identifyFoodFlow(input);
}

const prompt = ai.definePrompt({
  name: 'identifyFoodPrompt',
  input: {schema: IdentifyFoodInputSchema},
  output: {schema: IdentifyFoodOutputSchema},
  prompt: `You are an expert food identifier.

You will use this information to identify the food items in the image. You will make a determination as to whether the image contains food or not, and set the isFood output field appropriately.

If the image contains food, you will identify the food items and return them as an array of strings. If there is no food, return an empty array.

Use the following as the primary source of information about the image.

Photo: {{media url=photoDataUri}}`,
});

const identifyFoodFlow = ai.defineFlow(
  {
    name: 'identifyFoodFlow',
    inputSchema: IdentifyFoodInputSchema,
    outputSchema: IdentifyFoodOutputSchema,
  },
  async (input) => {
    const maxRetries = 3;
    let lastError: any;

    for (let i = 0; i < maxRetries; i++) {
      try {
        const {output} = await prompt(input);
        return output!;
      } catch (error: any) {
        lastError = error;
        const isServiceUnavailable =
          error.message?.includes('503') ||
          error.message?.includes('overloaded');
          
        if (isServiceUnavailable && i < maxRetries - 1) {
          console.warn(
            `AI model service unavailable. Retrying attempt ${i + 2} of ${maxRetries}...`
          );
          await new Promise(resolve =>
            setTimeout(resolve, 1000 * Math.pow(2, i))
          );
        } else {
          throw lastError;
        }
      }
    }
    throw lastError;
  }
);
